서비스 환경에서 개인정보와 중요한 데이터를 보호하는 일은 무엇보다 중요하며, 사용자 경험UX을 저해하지 않는 효율적인 인증 체계가 필수적입니다.   
이번 포스팅에서는 인증과 인가를 다루는 세션`Session`과 토큰`Token` 두 가지 방식의 개념과 차이점, 그리고 각 방식의 장단점에 대해 알아보도록 하겠습니다.

세션과 토큰에 대해 알아보기 전 인증`Authentication`과 인가`Authorization`, 그리고 HTTP의 비상태성`Stateless`에 대해 간단히 알아보도록 하겠습니다.

# 인증 (Authentication)

![Image](https://github.com/user-attachments/assets/4a935610-2f69-46e1-a3f8-d75f6ec3e74b)

인증 (Authentication)은 사용자의 신원을 확인하는 과정으로 즉, 누구인지 확인하는 절차입니다.   
쉽게말해 저희가 알고있는 `로그인`에 해당됩니다. 인증은 일반적으로  사용자에게 적절한 접근 권한을 부여하기 위한 첫 번째 단계로, 안전한 서비스 이용을 위한 기초를 마련합니다.

# 인가 (Authorization)

<img width="640" alt="Image" src="https://github.com/user-attachments/assets/88b8d63b-fda7-4d49-9258-a19f4d977b83" />

인가 (Authorization)는 `인증`된 사용자가 자원에 접근할 수 있는지를 결정하는 과정입니다.   
주요 기능으로는 사용자가 어떤 행동을 할 수 있는지에 대한 권한 부여 및 제한이 있습니다.   
즉, 사용자가 로그인 후 특정 페이지에 접근할 수 있는 권한이 있는지를 판단하는 과정입니다.   
예를들어 일반 사용자에게 `작성, 조회, 수정, 삭제`의 일반적인 작업에 대한 권한이 부여되어 있을 경우, `USER1`이 작성한 게시글에 대해 `USER2`는 `USER1의 리소스에 대해 인가되어있지 않기 때문`에 수정 및 삭제가 불가능합니다.   
같은 이유로 일반 사용자는 관리자 페이지에 대해 인가되어있지 않기때문에 관리자 페이지의 경우 일반 사용자는 접근이 불가능합니다.

# HTTP의 비상태성(Stateless)

HTTP의 비상태성 (Stateless)은 웹에서 클라이언트와 서버 간의 통신 방식 중 하나로, 서버가 클라이언트의 상태를 기억하지 않는 특성을 말합니다. 즉, 각 요청은 독립적이며 `이전 요청`의 정보나 상태를 저장하지 않습니다.   
이런 특성 때문에 인증 정보를 저장하고 관리하기 위해 세션 또는 토큰 방식의 인증을 사용합니다.

### 특징

- 독립적인 요청
  - 클라이언트가 서버에 요청할 때마다, 서버는 해당 요청을 독립적으로 처리합니다.
  - 이전 요청에 대한 정보는 서버에 저장되지 않기 때문에, 클라이언트는 매 요청마다 필요한 모든 정보를 포함해야 합니다.
- 상태 정보 저장 없음
  - 서버는 클라이언트의 상태를 유지하기 위해 추가적인 메모리를 사용하지 않아 자원의 효율적인 사용이 가능합니다.
  - 즉, 서버가 클라이언트의 상태를 기억하지 않기 때문에, 로그인 세션이나 사용자 인증 상태를 관리하기 위해 추가적인 방법이 필요합니다. 이를 위해 주로 `세션(Session)` 또는 `토큰(Token)` 방식이 사용됩니다.
- 예측 가능성
  - 클라이언트와 서버 간의 통신이 비상태성이기 때문에 각 요청은 예측 가능하고 처리하기가 간단합니다.
  - 클라이언트가 보낸 요청만을 바탕으로 응답이 결정되어 요청의 처리 방식이 일관되게 유지됩니다.

# 세션(Session) 기반 인증

세션(Session)은 클라이언트와 서버 간의 상태를 유지하기 위한 방법으로, 사용자가 로그인하여 인증된 후 해당 사용자의 정보를 일정 기간 동안 서버가 기억할 수 있도록 합니다.

## 세션의 작동 방식

<img width="640" alt="Image" src="https://github.com/user-attachments/assets/d9d2149f-95c4-4c61-bf34-ce9d5be485fc" />

1. `로그인 요청` : 사용자가 ID, Password를 입력하여 서버에 로그인 요청을 합니다.
2. `사용자 유효성 검증` : 서버는 데이터베이스에 저장된 정보를 통해 사용자의 입력에 대해 유효성을 검증합니다.
3. `세션 데이터 저장` : 유효성 검증이 완료된 후 서버는 해당 사용자에 대한 세션데이터를 서버메모리에 저장하고, 이를 식별 할 수 있는 세션 ID를 생성합니다.
4. `세션 ID 전송` : 서버는 생성된 세션 ID를 클라이언트에게 쿠키 형태로 전송합니다.
5. `세션 ID 저장` : 클라이언트는 서버로부터 전달받은 세션 ID를 쿠키에 저장합니다.
6. `리소스 요청` : 이후 클라이언트는 서버에 요청할 때마다 쿠키에 포함된 세션 ID를 함께 전송합니다.
7. `세션 유효성 검증` : 서버는 클라이언트로부터 받은 세션 ID를 사용하여 해당 세션 데이터를 조회하고, 유효한 세션인지 검증합니다.
8. `응답 전송` : 세션이 유효할 경우, 서버는 요청에 대한 응답을 클라이언트에게 전송합니다.

## 세션의 장단점

### 장점

- 상태 유지
  - 서버가 사용자 상태를 직접 관리하여 세션 정보를 통해 사용자 인증 상태를 쉽게 유지할 수 있습니다.
  - 사용자는 로그인 후 여러 페이지를 탐색하면서 인증 정보를 반복적으로 입력할 필요가 없습니다.
- 보안성
  - 세션 정보가 서버에 저장되어 클라이언트 측에 민감한 정보를 저장하지 않아 데이터 유출 위험이 줄어듭니다. 또한 서버에서 세션 정보를 쉽게 검증할 수 있습니다.
- 서버 제어
  - 세션 정보가 서버에 저장되어 관리자가 세션을 즉각적으로 쉽게 제어할 수 있습니다.
  - ex) 관리자가 특정 사용자`(비정상적인 사용자)의 세션을 강제로 종료시키면 해당 사용자는 로그아웃되어 추가적인 접근이 차단됩니다.
- 사용자 경험 개선
  - 사용자는 로그인 후 계속 인증된 상태로 서비스를 이용할 수 있어 편리합니다.
  - 로그인 후 여러작업을 수행하는 것이 원활해집니다.
- 로깅 및 분석
  - 서버는 세션 정보를 통해 사용자 행동을 추적하고 분석할 수 있어 사용자 맞춤형 서비스를 제공하는데 유리합니다.

### 단점

- 서버 자원 소모
  - 모든 세션 정보를 서버 메모리에 저장하여 많은 사용자가 동시에 접속할 경우 서버의 메모리 사용량이 급증하여 서버에 부하가 발생할 수 있습니다.
- 스케일링의 어려움
  - 세션 정보가 서버에 저장되기 때문에, 여러 서버 간의 세션 공유가 필요할 경우 복잡성이 증가합니다.
  - ex) 여러 서버에서 로드 밸런싱을 사용하는 경우, 사용자의 세션이 특정 서버에만 존재하면 다른 서버에서 세션 정보를 확인할 수 없게 됩니다.
- 세션 하이재킹 위험
  - 공격자가 세션 ID를 탈취하여 사용자의 세션을 가로채 공격자가 인증된 사용자로 가장할 수 있는 위험이 있습니다.
  - ex) 사용자가 공용 Wi-Fi를 통해 서비스에 접속할 때 세션 ID가 노출되면, 공격자가 이를 이용해 사용자의 계정을 탈취할 수 있습니다.
- 장시간 비활성 상태에서의 불편함
  - 사용자가 오랜 시간 동안 활동하지 않으면 세션이 만료될 수 있습니다. 이 경우 사용자는 다시 로그인을 해야 하므로 불편함이 발생할 수 있습니다.
  - ex) 사용자가 몇 시간 동안 애플리케이션을 열어두고 아무 작업도 하지 않으면, 세션이 만료되어 다시 인증해야하며 이 과정에서 데이터 손실이 발생할 수 있습니다.
- 브라우저 종속성
  - 세션 ID는 클라이언트의 쿠키에 저장되어 사용자가 다른 브라우저나 기기로 이동할 경우 인증상태가 유지되지 않습니다.
  - ex) 사용자가 데스크탑에서 로그인 후 모바일 기기로 이동할 경우, 다시 로그인을 해야 하므로 사용자 경험이 저하됩니다.

## 세션 정리

`세션(Session) 기반 인증`은 클라이언트가 로그인 시 서버에 세션을 생성하고, 이를 통해 사용자의 인증 상태를 유지하는 방식입니다.   
서버는 유효성 검증을 통해 세션 데이터를 메모리에 저장하고, 클라이언트에게 고유한 세션 ID를 쿠키로 전송합니다. 이후 클라이언트는 요청 시마다 세션 ID를 함께 전송하여 인증된 상태를 유지합니다.
세션 기반 인증은 직관적이고, 보안성과 사용자 경험을 개선하는데 유리하지만 서버 확장과 보안 관리에 추가적인 노력이 필요합니다.
